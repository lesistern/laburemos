name: Deploy to Production

on:
  push:
    branches: [ main ]
  release:
    types: [ published ]
  workflow_dispatch:
    inputs:
      rollback_version:
        description: 'Version to rollback to (leave empty for normal deployment)'
        required: false

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: laburemos-production
  ECS_SERVICE_FRONTEND: laburemos-frontend-production
  ECS_SERVICE_BACKEND: laburemos-backend-production
  ECR_REPOSITORY_FRONTEND: public.ecr.aws/laburemos/frontend
  ECR_REPOSITORY_BACKEND: public.ecr.aws/laburemos/backend

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    outputs:
      frontend-url: ${{ steps.deploy-infra.outputs.frontend-url }}
      backend-url: ${{ steps.deploy-infra.outputs.backend-url }}
      rds-endpoint: ${{ steps.deploy-infra.outputs.rds-endpoint }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy CloudFormation stack
        id: deploy-infra
        run: |
          aws cloudformation deploy \
            --template-file infrastructure/aws/cloudformation-production.yml \
            --stack-name laburemos-production \
            --parameter-overrides \
              Environment=production \
              DatabasePassword=${{ secrets.DB_PASSWORD_PRODUCTION }} \
              RedisAuthToken=${{ secrets.REDIS_AUTH_TOKEN_PRODUCTION }} \
              CertificateArn=${{ secrets.SSL_CERTIFICATE_ARN }} \
              DomainName=${{ secrets.DOMAIN_NAME }} \
            --capabilities CAPABILITY_IAM \
            --region ${{ env.AWS_REGION }}
          
          # Get outputs
          FRONTEND_URL=$(aws cloudformation describe-stacks \
            --stack-name laburemos-production \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontURL`].OutputValue' \
            --output text)
          
          BACKEND_URL=$(aws cloudformation describe-stacks \
            --stack-name laburemos-production \
            --query 'Stacks[0].Outputs[?OutputKey==`ApplicationLoadBalancerURL`].OutputValue' \
            --output text)
          
          RDS_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name laburemos-production \
            --query 'Stacks[0].Outputs[?OutputKey==`RDSEndpoint`].OutputValue' \
            --output text)
          
          echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "backend-url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "rds-endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT

  backup-database:
    name: Backup Database
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create RDS Snapshot
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          SNAPSHOT_ID="laburemos-production-pre-deploy-$TIMESTAMP"
          
          aws rds create-db-snapshot \
            --db-instance-identifier laburemos-production \
            --db-snapshot-identifier $SNAPSHOT_ID
          
          echo "Created snapshot: $SNAPSHOT_ID"
          echo "SNAPSHOT_ID=$SNAPSHOT_ID" >> $GITHUB_ENV

      - name: Wait for snapshot completion
        run: |
          aws rds wait db-snapshot-completed \
            --db-snapshot-identifier $SNAPSHOT_ID

  migrate-database:
    name: Migrate Database
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, backup-database]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Run database migrations
        run: |
          cd backend
          npx prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_PRODUCTION }}

  blue-green-deploy-backend:
    name: Blue-Green Deploy Backend
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, migrate-database]
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current service configuration
        run: |
          # Store current task definition ARN for rollback
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE_BACKEND }} \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "CURRENT_TASK_DEF=$CURRENT_TASK_DEF" >> $GITHUB_ENV

      - name: Create new task definition
        run: |
          # Get base task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition laburemos-backend-production \
            --query 'taskDefinition' \
            --output json)
          
          # Determine image tag
          if [ "${{ github.event.inputs.rollback_version }}" != "" ]; then
            IMAGE_TAG="${{ github.event.inputs.rollback_version }}"
          else
            IMAGE_TAG="${{ github.sha }}"
          fi
          
          # Update image URI
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE_URI "$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" \
            '.containerDefinitions[0].image = $IMAGE_URI | 
             del(.taskDefinitionArn) | 
             del(.revision) | 
             del(.status) | 
             del(.requiresAttributes) | 
             del(.placementConstraints) | 
             del(.compatibilities) | 
             del(.registeredAt) | 
             del(.registeredBy)')
          
          # Register new task definition
          echo $NEW_TASK_DEFINITION > backend-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://backend-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "NEW_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Deploy new version
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE_BACKEND }} \
            --task-definition $NEW_TASK_DEF_ARN

      - name: Wait for deployment to stabilize
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE_BACKEND }}

      - name: Health check after deployment
        id: health-check
        run: |
          for i in {1..20}; do
            if curl -f "${{ needs.deploy-infrastructure.outputs.backend-url }}/health"; then
              echo "Health check passed"
              echo "HEALTH_CHECK_PASSED=true" >> $GITHUB_OUTPUT
              break
            fi
            echo "Health check attempt $i failed, retrying in 30s..."
            sleep 30
          done
          
          if [ "$i" -eq 20 ]; then
            echo "Health check failed after 20 attempts"
            echo "HEALTH_CHECK_PASSED=false" >> $GITHUB_OUTPUT
          fi

      - name: Rollback on health check failure
        if: steps.health-check.outputs.HEALTH_CHECK_PASSED == 'false'
        run: |
          echo "Rolling back due to health check failure"
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE_BACKEND }} \
            --task-definition $CURRENT_TASK_DEF
          
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE_BACKEND }}
          
          exit 1

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, blue-green-deploy-backend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Build frontend
        run: |
          cd frontend
          npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ needs.deploy-infrastructure.outputs.backend-url }}
          NEXT_PUBLIC_ENVIRONMENT: production

      - name: Create backup of current deployment
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          aws s3 sync s3://laburemos-frontend-production s3://laburemos-frontend-production-backup-$TIMESTAMP

      - name: Deploy to S3
        run: |
          cd frontend
          aws s3 sync out/ s3://laburemos-frontend-production --delete

      - name: Invalidate CloudFront cache
        run: |
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name laburemos-production \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
            --output text)
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          # Wait for invalidation to complete
          aws cloudfront wait invalidation-completed \
            --distribution-id $DISTRIBUTION_ID \
            --id $INVALIDATION_ID

  post-deployment-tests:
    name: Post-Deployment Tests
    runs-on: ubuntu-latest
    needs: [deploy-frontend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Playwright
        run: |
          npm install -g @playwright/test
          npx playwright install

      - name: Run production smoke tests
        run: |
          npx playwright test --config=e2e/playwright.production.config.js
        env:
          BASE_URL: ${{ needs.deploy-infrastructure.outputs.frontend-url }}
          API_URL: ${{ needs.deploy-infrastructure.outputs.backend-url }}

      - name: Run load tests
        run: |
          # Install artillery for load testing
          npm install -g artillery
          artillery run e2e/load-tests/production-load-test.yml

  setup-monitoring:
    name: Setup Monitoring
    runs-on: ubuntu-latest
    needs: [post-deployment-tests]
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup CloudWatch Alarms
        run: |
          # Create high CPU alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "LaburemosProd-HighCPU" \
            --alarm-description "Alarm when CPU exceeds 70%" \
            --metric-name CPUUtilization \
            --namespace AWS/ECS \
            --statistic Average \
            --period 300 \
            --threshold 70 \
            --comparison-operator GreaterThanThreshold \
            --evaluation-periods 2 \
            --alarm-actions "arn:aws:sns:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:laburemos-alerts"
          
          # Create high memory alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "LaburemosProd-HighMemory" \
            --alarm-description "Alarm when Memory exceeds 80%" \
            --metric-name MemoryUtilization \
            --namespace AWS/ECS \
            --statistic Average \
            --period 300 \
            --threshold 80 \
            --comparison-operator GreaterThanThreshold \
            --evaluation-periods 2 \
            --alarm-actions "arn:aws:sns:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:laburemos-alerts"

      - name: Create Dashboard
        run: |
          aws cloudwatch put-dashboard \
            --dashboard-name "LaburemosProduction" \
            --dashboard-body file://monitoring/cloudwatch-dashboard.json

  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [setup-monitoring]
    if: always()
    
    steps:
      - name: Notify Slack on Success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: |
            üéâ Production deployment successful!
            üåê Frontend: ${{ needs.deploy-infrastructure.outputs.frontend-url }}
            üîß Backend: ${{ needs.deploy-infrastructure.outputs.backend-url }}
            üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=LaburemosProduction
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on Failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          text: |
            üö® Production deployment failed for commit ${{ github.sha }}!
            Check the logs and consider rollback if necessary.
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub Release
        if: success() && github.event_name == 'push'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Production Release v${{ github.run_number }}
          body: |
            üöÄ Production deployment completed successfully
            
            **Deployment Details:**
            - Commit: ${{ github.sha }}
            - Frontend URL: ${{ needs.deploy-infrastructure.outputs.frontend-url }}
            - Backend URL: ${{ needs.deploy-infrastructure.outputs.backend-url }}
            
            **Features:**
            - Blue-green deployment with automatic rollback
            - Database backup before deployment
            - Health checks and monitoring setup
            - Load testing completed
          draft: false
          prerelease: false